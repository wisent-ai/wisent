name: Sync Commits to Linear

on:
  push:
    branches: ['**']
  workflow_dispatch:

jobs:
  sync-to-linear:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 10

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Process commits and sync to Linear
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          cat << 'SCRIPT' > sync.js
          const https = require('https');

          const LINEAR_API_KEY = process.env.LINEAR_API_KEY;
          const REPO = process.env.GITHUB_REPOSITORY;
          const BRANCH = process.env.GITHUB_REF_NAME;
          const SHA = process.env.GITHUB_SHA;
          const ACTOR = process.env.GITHUB_ACTOR;

          async function linearQuery(query, variables = {}) {
            return new Promise((resolve, reject) => {
              const data = JSON.stringify({ query, variables });
              const options = {
                hostname: 'api.linear.app',
                path: '/graphql',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': LINEAR_API_KEY,
                }
              };
              const req = https.request(options, (res) => {
                let body = '';
                res.on('data', chunk => body += chunk);
                res.on('end', () => {
                  const parsed = JSON.parse(body);
                  if (parsed.errors) reject(new Error(JSON.stringify(parsed.errors)));
                  else resolve(parsed.data);
                });
              });
              req.on('error', reject);
              req.write(data);
              req.end();
            });
          }

          async function getCommitMessages() {
            const { execSync } = require('child_process');
            const log = execSync('git log -10 --pretty=format:"%H|%s|%an"').toString();
            return log.split('\n').map(line => {
              const [sha, message, author] = line.split('|');
              return { sha, message, author };
            });
          }

          async function main() {
            const commits = await getCommitMessages();
            console.log('Processing', commits.length, 'commits...\n');

            // Get team and states
            const teamQuery = `
              query {
                teams { nodes { id name states { nodes { id name } } } }
              }
            `;
            const teamData = await linearQuery(teamQuery);
            const team = teamData.teams.nodes.find(t => t.name === 'Wisent');
            if (!team) {
              console.log('Team Wisent not found');
              return;
            }
            const inProgressState = team.states.nodes.find(s => s.name === 'In Progress');
            const doneState = team.states.nodes.find(s => s.name === 'Done');

            for (const commit of commits) {
              console.log('Commit:', commit.sha.substring(0, 7), '-', commit.message);

              // Check for WIS-XXX pattern in commit message
              const ticketMatch = commit.message.match(/WIS-(\d+)/gi);

              if (ticketMatch) {
                for (const ticketId of ticketMatch) {
                  console.log('  Found ticket reference:', ticketId);

                  // Get issue
                  const issueQuery = `query { issue(id: "${ticketId}") { id identifier state { name } } }`;
                  try {
                    const issueData = await linearQuery(issueQuery);
                    if (issueData.issue) {
                      // Add comment with commit info
                      const commentMutation = `
                        mutation CreateComment($input: CommentCreateInput!) {
                          commentCreate(input: $input) { success }
                        }
                      `;
                      const comment = `Commit [${commit.sha.substring(0, 7)}](https://github.com/${REPO}/commit/${commit.sha}) by ${commit.author} on \`${BRANCH}\`:\n\n> ${commit.message}`;

                      await linearQuery(commentMutation, {
                        input: { issueId: issueData.issue.id, body: comment }
                      });
                      console.log('  Added comment to', ticketId);

                      // If commit message contains "fix", "close", "done", mark as done
                      const doneKeywords = /\b(fix|fixes|fixed|close|closes|closed|done|complete|completed|resolve|resolves|resolved)\b/i;
                      if (doneKeywords.test(commit.message) && doneState) {
                        const updateMutation = `
                          mutation UpdateIssue($id: String!, $input: IssueUpdateInput!) {
                            issueUpdate(id: $id, input: $input) { success }
                          }
                        `;
                        await linearQuery(updateMutation, {
                          id: issueData.issue.id,
                          input: { stateId: doneState.id }
                        });
                        console.log('  Marked', ticketId, 'as Done');
                      }
                    }
                  } catch (e) {
                    console.log('  Error processing', ticketId + ':', e.message);
                  }
                }
              }
            }

            console.log('\nDone!');
          }

          main().catch(e => {
            console.error('Error:', e.message);
            process.exit(1);
          });
          SCRIPT
          node sync.js
