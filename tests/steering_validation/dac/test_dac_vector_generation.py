#!/usr/bin/env python3
"""
Test DAC vector generation correctness by comparing our implementation
with reference data generated by the original DAC implementation.

This test loads the ITA and ENG datasets, generates DAC steering vectors
using our wisent-guard tensor-based implementation, and compares with reference
vectors generated by the original DAC implementation.
"""

import json
import time
import torch
import torch.nn.functional as F
import pytest
import sys
from pathlib import Path
from typing import List, Dict, Any, Tuple

# Add wisent-guard to path
WISENT_PATH = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(WISENT_PATH))

# Import wisent-guard tensor-based DAC
from wisent_guard.core.steering_methods_tensor.dac_attention import DAC
from wisent_guard.core.contrastive_pairs import ContrastivePairSet, ContrastivePair
from wisent_guard.core.response import PositiveResponse, NegativeResponse

# Add current directory to path for local imports
sys.path.insert(0, str(Path(__file__).parent))

from const import (
    MODEL_NAME,
    DIFF_ACTIVATIONS_PATH,
    DATASET_A_NAME,
    DATASET_B_NAME,
    MAX_EXAMPLES,
    MAX_NEW_TOKENS,
    ICL_EXAMPLES,
    REFERENCE_DATA_PATH,
    TORCH_DTYPE,
    COSINE_SIMILARITY_THRESHOLD,
)

# Import aggressive_memory_cleanup
utils_path = Path(__file__).parent.parent / "utils.py"
sys.path.insert(0, str(Path(__file__).parent.parent))
from utils import aggressive_memory_cleanup


def load_datasets() -> Tuple[List[Dict], List[Dict]]:
    """Load ITA and ENG datasets from reference_data directory."""
    # Load ITA dataset
    ita_path = REFERENCE_DATA_PATH / "ita_train.json"
    with open(ita_path, "r", encoding="utf-8") as f:
        ita_data = json.load(f)

    # Load ENG dataset
    eng_path = REFERENCE_DATA_PATH / "eng_train.json"
    with open(eng_path, "r", encoding="utf-8") as f:
        eng_data = json.load(f)

    return ita_data, eng_data


def create_contrastive_pairs(ita_data: List[Dict], eng_data: List[Dict]) -> ContrastivePairSet:
    """
    Create ContrastivePairSet where ITA responses are positive and ENG responses are negative.

    Args:
        ita_data: Italian dataset
        eng_data: English dataset

    Returns:
        ContrastivePairSet with language pairs
    """
    pairs = []
    max_pairs = min(len(ita_data), len(eng_data), MAX_EXAMPLES)

    for i in range(max_pairs):
        ita_item = ita_data[i]
        eng_item = eng_data[i]

        # Ensure both have the same input
        assert ita_item["input"] == eng_item["input"], f"Mismatched inputs at index {i}"

        prompt = ita_item["input"]
        ita_response = ita_item["output"]
        eng_response = eng_item["output"]

        # Create responses (ITA as positive, ENG as negative for steering toward Italian)
        pos_response = PositiveResponse(text=ita_response)
        neg_response = NegativeResponse(text=eng_response)

        # Create contrastive pair
        pair = ContrastivePair(
            prompt=prompt, positive_response=pos_response, negative_response=neg_response, label="language_steering"
        )

        pairs.append(pair)

    # Create ContrastivePairSet
    pair_set = ContrastivePairSet(name="ita_eng_language_steering", pairs=pairs, task_type="language_steering")

    return pair_set


def compare_with_reference(our_tensor: torch.Tensor) -> Dict[str, Any]:
    """
    Compare our generated tensor with reference vectors.

    Args:
        our_tensor: Our generated DAC tensor

    Returns:
        Dictionary with comparison metrics
    """
    results = {}

    # Load and compare with difference activations (the main steering tensor)
    if DIFF_ACTIVATIONS_PATH.exists():
        ref_tensor = torch.load(DIFF_ACTIVATIONS_PATH, map_location="cpu")

        # Ensure tensors are on same device
        our_tensor_cpu = our_tensor.cpu()
        ref_tensor_cpu = ref_tensor.cpu()

        # Calculate metrics
        cosine_sim = F.cosine_similarity(our_tensor_cpu.flatten(), ref_tensor_cpu.flatten(), dim=0).item()
        mse = F.mse_loss(our_tensor_cpu, ref_tensor_cpu).item()

        results["diff_tensor"] = {
            "cosine_similarity": cosine_sim,
            "mse": mse,
            "our_shape": list(our_tensor.shape),
            "ref_shape": list(ref_tensor.shape),
            "our_norm": torch.norm(our_tensor_cpu).item(),
            "ref_norm": torch.norm(ref_tensor_cpu).item(),
            "shapes_match": our_tensor.shape == ref_tensor.shape,
        }
    else:
        pytest.skip(f"Reference tensor not found at {DIFF_ACTIVATIONS_PATH}")

    return results


@pytest.mark.slow
class TestDACTensorGeneration:
    """Test suite for DAC tensor generation validation."""

    @pytest.mark.slow
    @pytest.mark.heavy
    def test_dac_tensor_generation_with_reference(self):
        """Test DAC tensor generation and compare with reference vectors."""
        # Skip if no GPU available (DAC is resource-intensive)
        if not torch.cuda.is_available():
            pytest.skip("GPU not available for DAC tensor generation")

        # Aggressive memory cleanup before starting
        aggressive_memory_cleanup()

        try:
            print("\n" + "=" * 70)
            print("DAC Tensor Generation Test")
            print("=" * 70)
            print(f"Model: {MODEL_NAME}")
            print(f"Datasets: {DATASET_A_NAME} vs {DATASET_B_NAME}")
            print(f"Examples: {MAX_EXAMPLES}")
            print(f"Max new tokens: {MAX_NEW_TOKENS}")
            print("=" * 70)

            # Step 1: Load datasets
            print("\n[1/5] Loading datasets...")
            ita_data, eng_data = load_datasets()
            assert len(ita_data) >= MAX_EXAMPLES, f"Insufficient ITA data: {len(ita_data)}"
            assert len(eng_data) >= MAX_EXAMPLES, f"Insufficient ENG data: {len(eng_data)}"
            print(f"‚úì Loaded {len(ita_data)} ITA and {len(eng_data)} ENG examples")

            # Step 2: Create contrastive pairs
            print("\n[2/5] Creating contrastive pairs...")
            contrastive_pairs = create_contrastive_pairs(ita_data, eng_data)
            assert len(contrastive_pairs.pairs) == MAX_EXAMPLES
            print(f"‚úì Created {len(contrastive_pairs.pairs)} contrastive pairs")

            # Step 3: Initialize DAC method
            print("\n[3/5] Initializing DAC tensor-based method...")
            dac_method = DAC(
                device="cuda:0" if torch.cuda.is_available() else "cpu",
                model_name=MODEL_NAME,
                max_examples=MAX_EXAMPLES,
                max_new_tokens=MAX_NEW_TOKENS,
                torch_dtype=TORCH_DTYPE,
            )
            print(f"‚úì DAC method initialized: {dac_method}")

            # Step 4: Train DAC using contrastive pairs
            print("\n[4/5] Training DAC with tensor extraction...")
            start_time = time.time()
            training_stats = dac_method.train_property("language_steering", contrastive_pairs)
            training_time = time.time() - start_time

            assert training_stats["success"], "DAC training failed"
            assert "tensor_norm" in training_stats
            assert "tensor_shape" in training_stats

            print(f"‚úì DAC training completed in {training_time:.1f} seconds")
            print(f"  Tensor shape: {training_stats['tensor_shape']}")
            print(f"  Tensor norm: {training_stats['tensor_norm']:.4f}")

            # Step 5: Compare with reference
            print("\n[5/5] Comparing with reference vectors...")
            steering_tensor = dac_method.get_steering_tensor()
            comparison_results = compare_with_reference(steering_tensor)

            # Display comparison results
            if "diff_tensor" in comparison_results:
                metrics = comparison_results["diff_tensor"]
                cosine_sim = metrics["cosine_similarity"]
                mse = metrics["mse"]
                shapes_match = metrics["shapes_match"]

                print(f"\nüìä Comparison Results:")
                print(f"  Cosine similarity: {cosine_sim:.6f}")
                print(f"  MSE: {mse:.8f}")
                print(f"  Our shape: {metrics['our_shape']}")
                print(f"  Ref shape: {metrics['ref_shape']}")
                print(f"  Our norm: {metrics['our_norm']:.4f}")
                print(f"  Ref norm: {metrics['ref_norm']:.4f}")
                print(f"  Shapes match: {shapes_match}")

                # STRICT ASSERTIONS
                assert cosine_sim > 0.99, f"‚ùå Cosine similarity {cosine_sim:.6f} is below threshold 0.99"
                assert mse < 1e-6, f"‚ùå MSE {mse:.8f} is too high (should be < 1e-6)"
                assert shapes_match, f"‚ùå Tensor shapes don't match: {metrics['our_shape']} vs {metrics['ref_shape']}"

                # Additional quality checks
                norm_ratio = metrics["our_norm"] / metrics["ref_norm"]
                assert 0.95 < norm_ratio < 1.05, (
                    f"‚ùå Norm ratio {norm_ratio:.4f} is outside acceptable range [0.95, 1.05]"
                )

                print(f"\n‚úÖ All assertions passed!")
                print(f"‚úÖ DAC tensor generation matches reference with cosine similarity > 0.99")

            print("\n" + "=" * 70)
            print("SUCCESS: DAC tensor generation test completed!")
            print("=" * 70)

        finally:
            # Clean up GPU memory
            aggressive_memory_cleanup()

    def test_dac_tensor_save_load(self):
        """Test saving and loading DAC tensor."""
        if not torch.cuda.is_available():
            pytest.skip("GPU not available for DAC tensor generation")

        save_path = REFERENCE_DATA_PATH / "test_dac_method.pt"

        try:
            # Initialize DAC
            dac_method = DAC(device="cuda:0" if torch.cuda.is_available() else "cpu", model_name=MODEL_NAME)

            # Try to load existing tensor
            if save_path.exists():
                success = dac_method.load_steering_tensor(str(save_path))
                assert success, "Failed to load DAC tensor"

                # Verify loaded tensor
                tensor = dac_method.get_steering_tensor()
                assert tensor is not None
                assert tensor.shape[0] == MAX_NEW_TOKENS  # Check steps dimension

                # Get statistics
                stats = dac_method.get_statistics()
                assert stats["is_trained"]
                assert stats["method"] == "DAC"
                assert "steering_tensor_shape" in stats

                print(f"‚úÖ Successfully loaded DAC tensor from {save_path}")
                print(f"  Shape: {stats['steering_tensor_shape']}")
                print(f"  Norm: {stats['steering_tensor_norm']:.4f}")
            else:
                pytest.skip(f"No saved tensor found at {save_path}")

        finally:
            aggressive_memory_cleanup()
